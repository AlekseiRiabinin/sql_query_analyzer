name: CI/CD - SQL Query Analyzer

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  POSTGRES_USER: postgres
  POSTGRES_DB: vtb_db
  POSTGRES_PASSWORD: postgres
  API_PORT: 8000

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and start services
      run: |
        docker compose -f docker-compose.yml up --build -d postgres api
      env:
        POSTGRES_USER: ${{ env.POSTGRES_USER }}
        POSTGRES_DB: ${{ env.POSTGRES_DB }}
        POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
        API_PORT: ${{ env.API_PORT }}

    - name: Wait for PostgreSQL to be ready
      run: |
        for i in {1..30}; do
          if docker compose exec -T postgres pg_isready \
              -U ${{ env.POSTGRES_USER }} \
              -d ${{ env.POSTGRES_DB }}; then
            echo "Postgres is ready!"
            break
          fi
          echo "Waiting for Postgres..."
          sleep 2
        done

    - name: Generate test data in PostgreSQL
      run: |
        docker compose exec -T postgres \
          psql -U ${{ env.POSTGRES_USER }} \
              -d ${{ env.POSTGRES_DB }} << EOF
        CREATE TABLE IF NOT EXISTS employees (
            id SERIAL PRIMARY KEY,
            name TEXT NOT NULL,
            department TEXT NOT NULL,
            salary NUMERIC(10,2) NOT NULL,
            hire_date DATE NOT NULL DEFAULT CURRENT_DATE
        );

        INSERT INTO employees (name, department, salary)
        SELECT
            'Employee_' || g,
            CASE WHEN g % 5 = 0 THEN 'Engineering'
                 WHEN g % 5 = 1 THEN 'HR'
                 WHEN g % 5 = 2 THEN 'Finance'
                 WHEN g % 5 = 3 THEN 'Sales'
                 ELSE 'Marketing'
            END,
            (random() * 1000)::NUMERIC(10,2)
        FROM generate_series(1, 1000) g;
        EOF

    - name: Verify test data was created
      run: |
        docker compose exec -T postgres \
          psql -U ${{ env.POSTGRES_USER }} \
              -d ${{ env.POSTGRES_DB }} \
              -c "SELECT COUNT(*) FROM employees;"

    - name: Wait for API to be ready
      run: |
        sleep 5
        curl --retry 5 \
          --retry-delay 5 \
          --retry-all-errors \
          http://localhost:${{ env.API_PORT }}/health

    - name: Test analyze endpoint with real data
      run: |
        echo "Testing API analyze endpoint with various queries..."
        
        API_URL="http://localhost:${{ env.API_PORT }}/analyze"

        echo "Testing basic SELECT query..."
        QUERY="SELECT+*+FROM+employees"
        curl -X POST "$API_URL?query=$QUERY" \
          -H "Content-Type: application/json" --fail --silent --show-error

        echo "Testing WHERE clause query..."
        QUERY="SELECT+*+FROM+employees+WHERE+department+%3D+'Engineering'"
        curl -X POST "$API_URL?query=$QUERY" \
          -H "Content-Type: application/json" --fail --silent --show-error

        echo "Testing ORDER BY query..."
        QUERY="SELECT+*+FROM+employees+ORDER+BY+salary+DESC"
        curl -X POST "$API_URL?query=$QUERY" \
          -H "Content-Type: application/json" --fail --silent --show-error

        echo "All API tests completed successfully!"

    - name: Run comprehensive API tests
      run: |
        curl -f http://localhost:${{ env.API_PORT }}/health || exit 1       
   
        API_URL="http://localhost:${{ env.API_PORT }}/analyze"
        QUERY="SELECT+*+FROM+employees"
        
        response=$(curl -s -X POST "$API_URL?query=$QUERY")
        echo "$response" | jq . || exit 1
